#
# This file is part of Astarte.
#
# Copyright 2020 Ispirata Srl
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

defmodule Astarte.Streams.Blocks.DeviceEventsProducer do
  @moduledoc """
  This is a producer block that generates messages by polling consuming from an AMQP queue
  that contains a stream of `Astarte.Core.Triggers.SimpleEvents.SimpleEvent` generated by
  Data Updater Plant.

  To make Data Updater Plant populate the queue, a Trigger has to be installed, using the
  same routing_key that will be passed in the `start_link` options to this block.

  If the Event can't be decoded, no message is produced and the event is rejected from the
  queue.

  If the request succeeds, `DeviceEventsProducer` produces an `%Astarte.Streams.Message{}`
  containing
  these fields:
  * `key` contains a key in the format `REALM/DEVICE_ID/INTERFACE/PATH`.
  * `data` contains the value obtained by extracting the bson_value of the trigger.
  * `type` is inferred from the bson_value of the trigger.
  * `timestamp` contains the timestamp (in microseconds) contained in the trigger or,
  if it didn't contain one, the reception timestamp of the event.
  """

  use GenStage

  require Logger

  alias Astarte.Streams.Blocks.DeviceEventsProducer.{
    EventsDecoder,
    RabbitMQClient
  }

  @retry_timeout_ms 10_000

  defmodule State do
    @moduledoc false

    defstruct [
      :client,
      :consumer_tag,
      :channel,
      :config,
      :channel_ref,
      :conn_ref,
      :pending_demand,
      :message_queue
    ]
  end

  @doc """
  Starts the `DeviceEventsProducer`.

  ## Options

  * `:routing_key` (required) - The routing key used to bind the queue to the exchange
  * `:queue` - The name of the queue that gets declared by the block. Defaults to an
    autogenerated name.
  * `:connection` - A keyword list containing the options that will be passed to
    `AMQP.Connection.open/1`. Defaults to `[]`.
  * `:exchange` - The name of the exchange the queue will be bound to. Defaults to
    `"astarte_events"`
  * `:client` - A module that implements the
    `Astarte.Streams.Blocks.DeviceEventsProducer.AMQPClient` behaviour and that will
    be used to connect to AMQP. Defaults to
    `Astarte.Streams.Blocks.DeviceEventsProducer.RabbitMQClient`
  """
  @spec start_link(options) :: GenServer.on_start()
        when options: [option],
             option:
               {:routing_key, String.t()}
               | {:queue, String.t()}
               | {:connection, keyword()}
               | {:exchange, String.t()}
               | {:client, module()}
  def start_link(opts) do
    GenStage.start_link(__MODULE__, opts)
  end

  @impl true
  def init(opts) do
    Process.flag(:trap_exit, true)

    client = Keyword.get(opts, :client, RabbitMQClient)

    with {:ok, config} <- client.generate_config(opts) do
      state = %State{
        client: client,
        consumer_tag: nil,
        channel: nil,
        config: config,
        channel_ref: nil,
        conn_ref: nil,
        pending_demand: 0,
        message_queue: :queue.new()
      }

      send(self(), :connect)

      {:producer, state, dispatcher: GenStage.BroadcastDispatcher}
    else
      {:error, reason} ->
        {:stop, reason}

      _ ->
        {:stop, :init_error}
    end
  end

  @impl true
  def handle_demand(incoming_demand, %State{pending_demand: demand} = state) do
    dispatch_messages(%{state | pending_demand: demand + incoming_demand}, [])
  end

  @impl true
  def handle_info(:connect, state) do
    {:noreply, [], connect(state)}
  end

  def handle_info({:DOWN, ref, :process, _pid, _reason}, %{conn_ref: ref} = state) do
    {:noreply, [], connect(state)}
  end

  def handle_info({:DOWN, ref, :process, _pid, _reason}, %{channel_ref: ref} = state) do
    {:noreply, [], connect(state)}
  end

  def handle_info({:basic_consume_ok, %{consumer_tag: tag}}, state) do
    {:noreply, [], %{state | consumer_tag: tag}}
  end

  def handle_info({:basic_cancel, _}, state) do
    {:noreply, [], connect(state)}
  end

  def handle_info({:basic_cancel_ok, _}, state) do
    {:noreply, [], %{state | consumer_tag: nil}}
  end

  def handle_info({:basic_deliver, payload, meta}, state) do
    %State{
      client: client,
      channel: channel,
      message_queue: message_queue
    } = state

    case build_message(payload) do
      {:ok, message} ->
        client.ack(channel, meta.delivery_tag)

        new_message_queue = :queue.in(message, message_queue)
        new_state = %{state | message_queue: new_message_queue}

        dispatch_messages(new_state, [])

      {:error, _reason} ->
        client.reject(channel, meta.delivery_tag, requeue: false)
        {:noreply, [], state}
    end
  end

  defp build_message(amqp_payload) do
    with {:ok, simple_event} <- EventsDecoder.decode_simple_event(amqp_payload) do
      EventsDecoder.simple_event_to_message(simple_event)
    end
  end

  defp connect(%State{client: client} = state) do
    case client.setup_channel(state.config) do
      {:ok, channel} ->
        conn_ref = Process.monitor(channel.conn.pid)
        channel_ref = Process.monitor(channel.pid)
        consumer_tag = client.consume(channel, state.config)

        %{
          state
          | channel: channel,
            consumer_tag: consumer_tag,
            conn_ref: conn_ref,
            channel_ref: channel_ref
        }

      {:error, reason} ->
        Logger.warn(
          "Cannot connect to RabbitMQ: #{inspect(reason)}. Retrying in #{@retry_timeout_ms} ms"
        )

        Process.send_after(self(), :connect, @retry_timeout_ms)

        state
    end
  end

  defp dispatch_messages(%State{pending_demand: 0} = state, messages) do
    {:noreply, Enum.reverse(messages), state}
  end

  defp dispatch_messages(%State{pending_demand: demand, message_queue: queue} = state, messages) do
    case :queue.out(queue) do
      {{:value, message}, updated_queue} ->
        updated_state = %{state | pending_demand: demand - 1, message_queue: updated_queue}
        updated_messages = [message | messages]

        dispatch_messages(updated_state, updated_messages)

      {:empty, _queue} ->
        {:noreply, Enum.reverse(messages), state}
    end
  end
end
